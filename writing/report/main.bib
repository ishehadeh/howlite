@online{10SolvingConstraints,
  title = {10.5.2. {{Solving Constraints}} · {{Functional Programming}} in {{OCaml}}},
  url = {https://courses.cs.cornell.edu/cs3110/2021sp/textbook/interp/unification.html},
  urldate = {2024-04-28},
  file = {/home/ian/Zotero/storage/8XFJ7ES7/unification.html}
}

@book{ahoCompilersPrinciplesTechniques2007,
  title = {Compilers: Principles, Techniques, \& Tools},
  shorttitle = {Compilers},
  editor = {Aho, Alfred V. and Lam, Monica S. and Sethi, Ravi and Ullman, Jeffrey D.},
  date = {2007},
  edition = {2. ed., Pearson internat. ed},
  publisher = {Pearson Addison-Wesley},
  location = {Boston Munich},
  isbn = {978-0-321-48681-3 978-0-321-49169-5},
  langid = {english},
  pagetotal = {1009},
  keywords = {topic:programming-languages}
}

@online{AstgrepStructuralSearcha,
  title = {Ast-Grep | Structural Search/Rewrite Tool for Many Languages},
  url = {https://ast-grep.github.io/},
  urldate = {2024-04-30},
  file = {/home/ian/Zotero/storage/DMTMY4ZV/ast-grep.github.io.html}
}

@incollection{bessiereChapter3Constraint2006,
  title = {Chapter 3 - {{Constraint Propagation}}},
  booktitle = {Foundations of {{Artificial Intelligence}}},
  author = {Bessiere, Christian},
  editor = {Rossi, Francesca and family=Beek, given=Peter, prefix=van, useprefix=true and Walsh, Toby},
  date = {2006-01-01},
  series = {Handbook of {{Constraint Programming}}},
  volume = {2},
  pages = {29--83},
  publisher = {Elsevier},
  doi = {10.1016/S1574-6526(06)80007-6},
  url = {https://www.sciencedirect.com/science/article/pii/S1574652606800076},
  urldate = {2024-11-10},
  abstract = {This chapter discusses that constraint reasoning involves various types of techniques to tackle the inherent intractability of the problem of satisfying a set of constraints. Constraint propagation is one of those types of techniques. It is central to the process of solving a constraint problem and indispensable for constraint reasoning. The chapter examines that constraint propagation embeds any reasoning, which consists in explicitly forbidding values or combinations of values for some variables of a problem, because a given subset of its constraints cannot be satisfied otherwise. It is in constraint reasoning that this concept shows its most accomplished form. There is no other field in which the concept of constraint propagation appears in such a variety of forms, and in which its characteristics have been analyzed. The chapter reviews that it formalizes all constraint propagation approaches within a unifying framework and discusses the main existing types of constraint propagation.},
  file = {/home/ian/Zotero/storage/CYAHDMI7/Bessiere - 2006 - Chapter 3 - Constraint Propagation.pdf;/home/ian/Zotero/storage/Y5BIFIIX/constraint-propagation-bessiere.pdf;/home/ian/Zotero/storage/4MVIFU8I/S1574652606800076.html}
}

@inproceedings{carlssonOpenendedFiniteDomain1997,
  title = {An Open-Ended Finite Domain Constraint Solver},
  booktitle = {Programming {{Languages}}: {{Implementations}}, {{Logics}}, and {{Programs}}},
  author = {Carlsson, Mats and Ottosson, Greger and Carlson, Björn},
  editor = {Glaser, Hugh and Hartel, Pieter and Kuchen, Herbert},
  date = {1997},
  pages = {191--206},
  publisher = {Springer},
  location = {Berlin, Heidelberg},
  doi = {10.1007/BFb0033845},
  abstract = {We describe the design and implementation of a finite domain constraint solver embedded in a Prolog system using an extended unification mechanism via attributed variables as a generic constraint interface. The solver is essentially a scheduler for indexicals, i.e. reactive functional rules encoding local consistency methods performing incremental constraint solving or entailment checking, and global constraints, i.e. general propagators which may use specialized algorithms to achieve a higher degree of consistency or better time and space complexity.},
  isbn = {978-3-540-69537-0},
  langid = {english},
  file = {/home/ian/Zotero/storage/IR9PW7UY/Carlsson et al. - 1997 - An open-ended finite domain constraint solver.pdf}
}

@online{CatalogueOptimizingCompiler,
  title = {A {{Catalogue}} of {{Optimizing Compiler Transforms}}},
  url = {https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf},
  urldate = {2023-05-01},
  keywords = {compiler,optimization,reference}
}

@online{Catppuccin,
  title = {Catppuccin},
  url = {https://catppuccin.com},
  urldate = {2024-11-12},
  abstract = {A soothing pastel theme for the high-spirited! We are a community-driven color scheme, perfect for coding, designing, and more. Explore our color palettes, discover our wide range of ports, and view our vibrant community.},
  langid = {english},
  file = {/home/ian/Zotero/storage/DQRLU35A/catppuccin.com.html}
}

@book{compilers,
  title = {Compilers: {{Principles}}, {{Techniques}}, and {{Tools}}},
  shorttitle = {Compilers},
  author = {Aho, Alfred and Ullman, Jeffrey and Sethi, Ravi and Lam, Monica},
  date = {2006-08-31},
  edition = {2nd edition},
  publisher = {Addison Wesley},
  location = {Boston Munich},
  abstract = {Compilers: Principles, Techniques and Tools, known to professors, students, and developers worldwide as the "Dragon Book," is available in a new edition. Every chapter has been completely revised to reflect developments in software engineering, programming languages, and computer architecture that have occurred since 1986, when the last edition published. The authors, recognizing that few readers will ever go on to construct a compiler, retain their focus on the broader set of problems faced in software design and software development.},
  isbn = {978-0-321-48681-3},
  langid = {english},
  pagetotal = {1040}
}

@online{ConstraintPropagationCSE3220,
  title = {Constraint {{Propagation}} — {{CS-E3220}}: {{CSP}} - {{Constraint Satisfaction Problems}} Documentation},
  url = {https://users.aalto.fi/~tjunttil/2020-DP-AUT/notes-csp/propagation.html},
  urldate = {2024-07-28},
  file = {/home/ian/Zotero/storage/BREBQPM8/propagation.html}
}

@article{cp,
  title = {Copy-and-{{Patch Compilation}}: {{A}} Fast Compilation Algorithm for High-Level Languages and Bytecode},
  shorttitle = {Copy-and-{{Patch Compilation}}},
  author = {Xu, Haoran and Kjolstad, Fredrik},
  date = {2021-10-20},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {5},
  eprint = {2011.13127},
  eprinttype = {arXiv},
  eprintclass = {cs},
  pages = {1--30},
  issn = {2475-1421},
  doi = {10.1145/3485513},
  url = {http://arxiv.org/abs/2011.13127},
  urldate = {2024-04-26},
  abstract = {Fast compilation is important when compilation occurs at runtime, such as query compilers in modern database systems and WebAssembly virtual machines in modern browsers. We present copy-and-patch, an extremely fast compilation technique that also produces good quality code. It is capable of lowering both high-level languages and low-level bytecode programs to binary code, by stitching together code from a large library of binary implementation variants. We call these binary implementations stencils because they have holes where missing values must be inserted during code generation. We show how to construct a stencil library and describe the copy-and-patch algorithm that generates optimized binary code. We demonstrate two use cases of copy-and-patch: a compiler for a high-level C-like language intended for metaprogramming and a compiler for WebAssembly. Our high-level language compiler has negligible compilation cost: it produces code from an AST in less time than it takes to construct the AST. We have implemented an SQL database query compiler on top of this metaprogramming system and show that on TPC-H database benchmarks, copy-and-patch generates code two orders of magnitude faster than LLVM -O0 and three orders of magnitude faster than higher optimization levels. The generated code runs an order of magnitude faster than interpretation and 14\% faster than LLVM -O0. Our WebAssembly compiler generates code 4.9X-6.5X faster than Liftoff, the WebAssembly baseline compiler in Google Chrome. The generated code also outperforms Liftoff's by 39\%-63\% on the Coremark and PolyBenchC WebAssembly benchmarks.},
  issue = {OOPSLA},
  keywords = {Computer Science - Programming Languages},
  file = {/home/ian/Zotero/storage/IFPNP7YR/Xu and Kjolstad - 2021 - Copy-and-Patch Compilation A fast compilation algorithm for high-level languages and bytecode.pdf;/home/ian/Zotero/storage/GWGL26G4/2011.html}
}

@online{Cyclone,
  title = {Cyclone},
  url = {https://cyclone.thelanguage.org/},
  urldate = {2023-11-23},
  keywords = {open-source,programming-languages,reed:inspo},
  file = {/home/ian/Zotero/storage/XT9LQUKA/cyclone.thelanguage.org.html}
}

@article{cyclone_types,
  title = {Quantified Types in an Imperative Language},
  author = {Grossman, Dan},
  date = {2006-05-01},
  journaltitle = {ACM Transactions on Programming Languages and Systems},
  shortjournal = {ACM Trans. Program. Lang. Syst.},
  volume = {28},
  number = {3},
  pages = {429--475},
  issn = {0164-0925},
  doi = {10.1145/1133651.1133653},
  url = {https://dl.acm.org/doi/10.1145/1133651.1133653},
  urldate = {2024-04-26},
  abstract = {We describe universal types, existential types, and type constructors in Cyclone, a strongly typed C-like language. We show how the language naturally supports first-class polymorphism and polymorphic recursion while requiring an acceptable amount of explicit type information. More importantly, we consider the soundness of type variables in the presence of C-style mutation and the address-of operator. For polymorphic references, we describe a solution more natural for the C level than the ML-style “value restriction.” For existential types, we discover and subsequently avoid a subtle unsoundness issue resulting from the address-of operator. We develop a formal abstract machine and type-safety proof that capture the essence of type variables at the C level.},
  keywords = {Cyclone,existential types,polymorphism,type variables},
  file = {/home/ian/Zotero/storage/8LURK7JA/Grossman - 2006 - Quantified types in an imperative language.pdf}
}

@software{drmortalwombatOscar64Compiler2024,
  title = {Oscar64 {{C Compiler}}},
  author = {{drmortalwombat}},
  date = {2024-01-08T21:52:32Z},
  origdate = {2021-09-06T16:45:16Z},
  url = {https://github.com/drmortalwombat/oscar64},
  urldate = {2024-01-08},
  abstract = {Optimizing Small memory C Compiler Assembler and Runtime for C64}
}

@online{dunfieldBidirectionalTyping2020,
  title = {Bidirectional {{Typing}}},
  author = {Dunfield, Jana and Krishnaswami, Neel},
  date = {2020-11-14},
  eprint = {1908.05839},
  eprinttype = {arXiv},
  doi = {10.48550/arXiv.1908.05839},
  url = {http://arxiv.org/abs/1908.05839},
  urldate = {2024-10-09},
  abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner's local type inference to the present day, and provide guidance for future investigations.},
  pubstate = {prepublished},
  keywords = {type-checking},
  file = {/home/ian/Zotero/storage/5THLLAYA/Dunfield and Krishnaswami - 2020 - Bidirectional Typing.pdf;/home/ian/Zotero/storage/CDY2XX6M/1908.html}
}

@standard{ECMAScript2023,
  type = {Software},
  title = {{{ECMAScript}}},
  date = {2023-06},
  number = {262},
  url = {https://www.ecma-international.org/publications-and-standards/standards/ecma-262/},
  urldate = {2024-04-25},
  abstract = {ECMAScript® 2023 language specification, 14th edition - ECMAScript is a programming language based on several technologies like JavaScript.},
  langid = {american},
  version = {14},
  file = {/home/ian/Zotero/storage/984UY82I/ecma-262.html}
}

@incollection{fluetLinearRegionsAre2006,
  title = {Linear {{Regions Are All You Need}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Fluet, Matthew and Morrisett, Greg and Ahmed, Amal},
  editor = {Sestoft, Peter},
  date = {2006},
  volume = {3924},
  pages = {7--21},
  publisher = {Springer Berlin Heidelberg},
  location = {Berlin, Heidelberg},
  doi = {10.1007/11693024_2},
  url = {http://link.springer.com/10.1007/11693024_2},
  urldate = {2024-01-20},
  abstract = {The type-and-effects system of the Tofte-Talpin region calculus makes it possible to safely reclaim objects without a garbage collector. However, it requires that regions have last-in-first-out (LIFO) lifetimes following the block structure of the language. We introduce λrgnUL, a core calculus that is powerful enough to encode Tofte-Talpin-like languages, and that eliminates the LIFO restriction. The target language has an extremely simple, substructural type system. To prove the power of the language, we sketch how Tofte-Talpin-style regions, as well as the firstclass dynamic regions and unique pointers of the Cyclone programming language can be encoded in λrgnUL.},
  isbn = {978-3-540-33095-0 978-3-540-33096-7},
  langid = {english},
  file = {/home/ian/Zotero/storage/RGQ7M82N/Fluet et al. - 2006 - Linear Regions Are All You Need.pdf}
}

@online{GitHubAurghya0ProjectReportTypst,
  title = {{{GitHub}} - Aurghya-0/{{Project-Report-Typst}}: {{Project Report Format}} in {{Typst}}},
  url = {https://github.com/aurghya-0/Project-Report-Typst/tree/main},
  urldate = {2024-04-08},
  file = {/home/ian/Zotero/storage/ZHD5HWQX/main.html}
}

@software{go,
  title = {The {{Go Programming Language}}},
  url = {https://go.dev/},
  urldate = {2024-04-24},
  abstract = {Go is an open source programming language that makes it simple to build secure, scalable systems.},
  organization = {Google},
  file = {/home/ian/Zotero/storage/JXA4BPP6/go.dev.html}
}

@software{go-github,
  title = {Go},
  date = {2024-11-10T14:51:14Z},
  origdate = {2014-08-19T04:33:40Z},
  url = {https://github.com/golang/go},
  urldate = {2024-11-10},
  abstract = {The Go programming language},
  organization = {Google},
  keywords = {go,golang,language,programming-language}
}

@article{grossmanQuantifiedTypesImperative2006,
  title = {Quantified Types in an Imperative Language},
  author = {Grossman, Dan},
  date = {2006-05},
  journaltitle = {ACM Transactions on Programming Languages and Systems},
  shortjournal = {ACM Trans. Program. Lang. Syst.},
  volume = {28},
  number = {3},
  pages = {429--475},
  issn = {0164-0925, 1558-4593},
  doi = {10.1145/1133651.1133653},
  url = {https://dl.acm.org/doi/10.1145/1133651.1133653},
  urldate = {2024-01-17},
  abstract = {We describe universal types, existential types, and type constructors in Cyclone, a strongly typed C-like language. We show how the language naturally supports first-class polymorphism and polymorphic recursion while requiring an acceptable amount of explicit type information. More importantly, we consider the soundness of type variables in the presence of C-style mutation and the address-of operator. For polymorphic references, we describe a solution more natural for the C level than the ML-style “value restriction.” For existential types, we discover and subsequently avoid a subtle unsoundness issue resulting from the address-of operator. We develop a formal abstract machine and type-safety proof that capture the essence of type variables at the C level.},
  langid = {english},
  keywords = {topic:polymorphism},
  file = {/home/ian/Zotero/storage/U297MES5/Grossman - 2006 - Quantified types in an imperative language.pdf}
}

@incollection{gunterSemanticsTypesProgramming1995,
  title = {The {{Semantics}} of {{Types}} in {{Programming Languages}}},
  booktitle = {Handbook of {{Logic}} in {{Computer Science}}},
  author = {Gunter, Carl A},
  editor = {Abramsky, S and Gabbay, Dov M and Maibaum, T S E},
  date = {1995-04-27},
  pages = {395--476},
  publisher = {Oxford University PressOxford},
  doi = {10.1093/oso/9780198537625.003.0004},
  url = {https://academic.oup.com/book/52970/chapter/421961890},
  urldate = {2024-01-20},
  abstract = {Abstract             In the twentieth century, there have been at least two lines of development of the notion of a type. One of these uses types to conquer problems in the foundations of mathematics. For example, type distinctions can resolve troubling paradoxes that lead to inconsistent systems. But a second, more recent, line of investigation into types pursues their application in programming languages. Although computer architectures themselves suggest few type distinctions, ‘higher-level’ programming languages generally use a classification of data into types to serve a variety of different purposes. There are at least four motives for doing this.},
  isbn = {978-0-19-853762-5 978-1-383-02610-8},
  langid = {english},
  file = {/home/ian/Zotero/storage/RT4T8IF8/Gunter - 1995 - The Semantics of Types in Programming Languages.pdf}
}

@software{HareProgrammingLanguage,
  title = {The {{Hare}} Programming Language},
  url = {https://harelang.org/},
  urldate = {2023-11-20},
  abstract = {Hare is a systems programming language designed to be simple, stable, and robust. Hare uses a static type system, manual memory management, and a minimal runtime. It is well-suited to writing operating systems, system tools, compilers, networking software, and other low-level, high performance tasks.},
  keywords = {open-source,programming-languages}
}

@software{hedy,
  title = {Hedy: {{A Gradual Language}} for {{Programming Education}}},
  shorttitle = {Hedy},
  author = {Hermans, Felienne},
  date = {2024-11-10T10:49:55Z},
  doi = {https://dl.acm.org/doi/10.1145/3372782.3406262},
  url = {https://github.com/hedyorg/hedy},
  urldate = {2024-11-10},
  abstract = {Hedy is a gradual programming language to teach children programming. Gradual languages use different language levels, where each level adds new concepts and syntactic complexity. At the end of the Hedy level sequence, kids master a subset of syntactically valid Python.}
}

@article{hindley_types,
  title = {The {{Principal Type-Scheme}} of an {{Object}} in {{Combinatory Logic}}},
  author = {Hindley, R.},
  date = {1969},
  journaltitle = {Transactions of the American Mathematical Society},
  volume = {146},
  eprint = {1995158},
  eprinttype = {jstor},
  pages = {29--60},
  publisher = {American Mathematical Society},
  issn = {0002-9947},
  doi = {10.2307/1995158},
  url = {https://www.jstor.org/stable/1995158},
  urldate = {2024-04-26},
  file = {/home/ian/Zotero/storage/FA47R3ZP/Hindley - 1969 - The Principal Type-Scheme of an Object in Combinatory Logic.pdf}
}

@software{HomeZigProgramming,
  title = {Home ⚡ {{Zig Programming Language}}},
  url = {https://ziglang.org/},
  urldate = {2018-09-29},
  keywords = {open-source,programming-languages}
}

@online{HowLLVMOptimizes,
  title = {How {{LLVM Optimizes}} a {{Function}}},
  url = {https://blog.regehr.org/archives/1603},
  urldate = {2018-09-05},
  keywords = {blog-post,programming-languages}
}

@online{IcefoxGarnetExperiment,
  title = {\textasciitilde icefox/Garnet - {{Experiment}} with a Lightweight Systems Programming Language - Sourcehut Hg},
  url = {https://hg.sr.ht/~icefox/garnet},
  urldate = {2024-01-22},
  file = {/home/ian/Zotero/storage/WTKKJW8Z/garnet.html}
}

@online{IntroductionOperationalSemantics2017,
  title = {Introduction to {{Operational Semantics}}},
  date = {2017-03-24},
  url = {https://www.slideshare.net/jsinglet/introduction-to-operational-semantics},
  urldate = {2024-04-22},
  abstract = {Introduction to Operational Semantics  - Download as a PDF or view online for free},
  langid = {english},
  organization = {SlideShare},
  file = {/home/ian/Zotero/storage/F8RFANUG/introduction-to-operational-semantics.html}
}

@online{IntroductionProgrammingLanguage,
  title = {Introduction — {{Programming Language Principles}} and {{Paradigms}} 0.4-Alpha Documentation},
  url = {https://eecs390.github.io/notes/foundations.html},
  urldate = {2024-01-20},
  file = {/home/ian/Zotero/storage/JR22RRET/foundations.html}
}

@online{IntroductionRISCVUnderstanding,
  title = {An {{Introduction}} to {{RISC-V}}—{{Understanding RISC}}’s {{Open ISA}} - {{Technical Articles}}},
  url = {https://www.allaboutcircuits.com/technical-articles/introductions-to-risc-v-instruction-set-understanding-this-open-instruction-set-architecture/},
  urldate = {2024-02-12},
  abstract = {This article is a primer into the basics of RISC-V. The open architecture philosophy is exposed, along with a technical description of the modular ISA, and some commercial RISC-V microprocessor implementations.},
  langid = {english},
  file = {/home/ian/Zotero/storage/NUWAZG5S/introductions-to-risc-v-instruction-set-understanding-this-open-instruction-set-architecture.html}
}

@software{JaktProgrammingLanguage,
  title = {The Jakt Programming Language},
  url = {https://github.com/SerenityOS/jakt},
  urldate = {2022-10-13},
  keywords = {open-source,programming-languages}
}

@online{JournalStuffwithstuffCom,
  title = {Journal.Stuffwithstuff.Com},
  url = {https://journal.stuffwithstuff.com/},
  urldate = {2024-01-20},
  file = {/home/ian/Zotero/storage/MHD2785U/journal.stuffwithstuff.com.html}
}

@article{kajiSolvingUnificationProblem,
  title = {Solving a {{Unification Problem}} under {{Constrained Substitutions Using Tree Automata}}},
  author = {Kaji, Yuichi and Fujiwara, Toru and Kasami, Tadao},
  langid = {english},
  file = {/home/ian/Zotero/storage/ZBY4A9C7/Kaji et al. - Solving a Unification Problem under Constrained Substitutions Using Tree Automata.pdf}
}

@article{krishnamurthiProgrammingLanguagesApplication,
  title = {Programming {{Languages}}: {{Application}} and {{Interpretation}}},
  author = {Krishnamurthi, Shriram},
  langid = {english},
  file = {/home/ian/Zotero/storage/NER582CG/Krishnamurthi - Programming Languages Application and Interpretation.pdf}
}

@article{larsonAutomatedConjecturingIII2017,
  title = {Automated Conjecturing {{III}}},
  author = {Larson, C. E. and Van Cleemput, N.},
  date = {2017-12-01},
  journaltitle = {Annals of Mathematics and Artificial Intelligence},
  shortjournal = {Ann Math Artif Intell},
  volume = {81},
  number = {3},
  pages = {315--327},
  issn = {1573-7470},
  doi = {10.1007/s10472-017-9559-5},
  url = {https://doi.org/10.1007/s10472-017-9559-5},
  urldate = {2024-11-12},
  abstract = {Discovery in mathematics is a prototypical intelligent behavior, and an early and continuing goal of artificial intelligence research. We present a heuristic for producing mathematical conjectures of a certain typical form and demonstrate its utility. Our program conjectures relations that hold between properties of objects (property-relation conjectures). These objects can be of a wide variety of types. The statements are true for all objects known to the program, and are the simplest statements which are true of all these objects. The examples here include new conjectures for the hamiltonicity of a graph, a well-studied property of graphs. While our motivation and experiments have been to produce mathematical conjectures—and to contribute to mathematical research—other kinds of interesting property-relation conjectures can be imagined, and this research may be more generally applicable to the development of intelligent machinery.},
  langid = {english},
  keywords = {05-04,05C45,05C69,Artificial Intelligence,Automated conjecturing,Automated mathematical discovery,Property-relations conjectures}
}

@online{Lecture10Type,
  title = {Lecture 10: {{Type Checking}}},
  url = {https://course.ccs.neu.edu/cs4410sp19/lec_type-checking_notes.html},
  urldate = {2024-04-28},
  file = {/home/ian/Zotero/storage/JKH8KS8Y/lec_type-checking_notes.html}
}

@online{Lecture11Type,
  title = {Lecture 11: {{Type Inference}}},
  url = {https://course.ccs.neu.edu/cs4410sp19/lec_type-inference_notes.html},
  urldate = {2024-04-28},
  file = {/home/ian/Zotero/storage/ETSCMPZ2/lec_type-inference_notes.html}
}

@software{lekkitLekKitRVVM2024,
  title = {{{LekKit}}/{{RVVM}}},
  author = {LekKit},
  date = {2024-02-23T17:52:13Z},
  origdate = {2021-02-16T00:49:28Z},
  url = {https://github.com/LekKit/RVVM},
  urldate = {2024-02-26},
  abstract = {The RISC-V Virtual Machine},
  keywords = {c,emulation,emulator,emulators,instruction-decoding,jit,linux,risc,risc-v,riscv,riscv-emulator,riscv-linux,riscv-simulator,riscv32,riscv64,rvvm,tracing-jit,translation,virtual-machine,vm}
}

@online{lib_lalrpop,
  title = {Lalrpop/Lalrpop: {{LR}}(1) Parser Generator for {{Rust}}},
  url = {https://github.com/lalrpop/lalrpop},
  urldate = {2024-04-26},
  file = {/home/ian/Zotero/storage/4JXQ76PH/lalrpop.html}
}

@software{lib_logos,
  title = {Maciejhirsz/Logos},
  author = {Hirsz, Maciej},
  date = {2024-04-25T08:49:42Z},
  origdate = {2018-11-09T14:37:11Z},
  url = {https://github.com/maciejhirsz/logos},
  urldate = {2024-04-26},
  abstract = {Create ridiculously fast Lexers},
  keywords = {lexer,lexer-generator,parser,parsing,rust}
}

@online{MakingRISCVOS,
  title = {Making an {{RISC-V OS}} ({{Part}} 1): {{Project Setup}}},
  url = {https://traxys.me/riscv_os_setup.html},
  urldate = {2024-04-10}
}

@online{mangumRISCVBytesPrivilege2021,
  title = {{{RISC-V Bytes}}: {{Privilege Levels}}},
  shorttitle = {{{RISC-V Bytes}}},
  author = {Mangum, Daniel},
  date = {2021-12-27T00:10:34-06:00},
  url = {https://danielmangum.com/posts/risc-v-bytes-privilege-levels/},
  urldate = {2024-03-26},
  abstract = {This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page. It has been a bit since our last post, but today we are going to begin our journey into some of the more interesting areas of RISC-V systems. In the first post in the series, we installed our RISC-V toolchain, which included QEMU.},
  langid = {english},
  file = {/home/ian/Zotero/storage/3PI8ZQQA/risc-v-bytes-privilege-levels.html}
}

@online{matsakisLALRPOPBabySteps,
  title = {{{LALRPOP}} · Baby Steps},
  author = {Matsakis, Niko},
  url = {https://smallcultfollowing.com/babysteps/blog/2015/09/14/lalrpop/},
  urldate = {2023-12-23},
  abstract = {Announcement post for LALRPOP},
  keywords = {rust,topic:parser-generators,topic:programming-languages},
  file = {/home/ian/Zotero/storage/P59SNEEC/lalrpop.html}
}

@article{milner_types,
  title = {A Theory of Type Polymorphism in Programming},
  author = {Milner, Robin},
  date = {1978-12-01},
  journaltitle = {Journal of Computer and System Sciences},
  shortjournal = {Journal of Computer and System Sciences},
  volume = {17},
  number = {3},
  pages = {348--375},
  issn = {0022-0000},
  doi = {10.1016/0022-0000(78)90014-4},
  url = {https://www.sciencedirect.com/science/article/pii/0022000078900144},
  urldate = {2024-04-26},
  abstract = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot “go wrong” and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system.},
  file = {/home/ian/Zotero/storage/XCMZNCKZ/Milner - 1978 - A theory of type polymorphism in programming.pdf;/home/ian/Zotero/storage/T5S5JG9U/0022000078900144.html}
}

@online{null_c,
  title = {{{NULL}}},
  url = {https://en.cppreference.com/w/c/types/NULL},
  urldate = {2024-04-25},
  organization = {cppreference.com}
}

@online{null_cxx,
  title = {Nullptr},
  url = {https://en.cppreference.com/w/cpp/language/nullptr},
  urldate = {2024-04-25},
  organization = {cppreference.com},
  file = {/home/ian/Zotero/storage/64LU8K6Z/nullptr.html}
}

@online{null_java,
  title = {Chapter~3.~{{Lexical Structure}}},
  url = {https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.7},
  urldate = {2024-04-25},
  file = {/home/ian/Zotero/storage/ARBTY392/jls-3.html}
}

@online{ocaml,
  title = {{{OCaml}}},
  date = {2024-04-16},
  url = {https://ocaml.org},
  urldate = {2024-04-25},
  abstract = {OCaml is a general-purpose, industrial-strength programming language with an emphasis on expressiveness and safety.},
  langid = {english},
  organization = {OCaml},
  file = {/home/ian/Zotero/storage/LB87B8YW/ocaml.org.html}
}

@online{OdinProgrammingLanguage,
  title = {Odin {{Programming Language}}},
  url = {https://odin-lang.org/},
  urldate = {2023-05-10},
  abstract = {Odin is a general-purpose programming language with distinct typing built for high performance, modern systems and data-oriented programming. Odin is the C alternative for the Joy of Programming.},
  keywords = {open-source,programming-languages},
  file = {/home/ian/Zotero/storage/K7SE5GLC/odin-lang.org.html}
}

@online{pike_GoAtGoogle,
  title = {Go at {{Google}}: {{Language Design}} in the {{Service}} of {{Software Engineering}} - {{The Go Programming Language}}},
  shorttitle = {Go at {{Google}}},
  author = {Pike, Rob},
  date = {2012},
  url = {https://go.dev/talks/2012/splash.article},
  urldate = {2024-11-10},
  langid = {english},
  file = {/home/ian/Zotero/storage/IZ4WKXEE/splash.html}
}

@online{RangesetblazeCratesIo2024,
  title = {Range-Set-Blaze - Crates.Io: {{Rust Package Registry}}},
  shorttitle = {Range-Set-Blaze - Crates.Io},
  date = {2024-03-09},
  url = {https://crates.io/crates/range-set-blaze},
  urldate = {2024-09-22},
  abstract = {Integer sets as fast, sorted, integer ranges with full set operations}
}

@online{ReconstructingTypeScriptPart,
  title = {Reconstructing {{TypeScript}}, Part 0: Intro and Background},
  url = {https://jaked.org/blog/2021-09-07-Reconstructing-TypeScript-part-0},
  urldate = {2024-07-15},
  file = {/home/ian/Zotero/storage/2N3PU9FL/2021-09-07-Reconstructing-TypeScript-part-0.html}
}

@software{ref_cyclone,
  title = {Cyclone},
  date = {2001},
  url = {https://cyclone.thelanguage.org/},
  urldate = {2024-04-26},
  organization = {AT\&T Labs},
  file = {/home/ian/Zotero/storage/NWN53EQY/cyclone.thelanguage.org.html}
}

@software{ref_gleam,
  title = {Gleam-Lang/Gleam},
  date = {2024-04-26T09:54:28Z},
  origdate = {2016-06-30T20:52:30Z},
  url = {https://github.com/gleam-lang/gleam},
  urldate = {2024-04-26},
  abstract = {⭐️ A friendly language for building type-safe, scalable systems!},
  organization = {Gleam},
  keywords = {compiler,erlang,gleam,programming-language,statically-typed}
}

@software{ref_gluon,
  title = {Gluon-Lang/Gluon},
  date = {2024-04-25T10:54:37Z},
  origdate = {2015-08-02T12:35:56Z},
  url = {https://github.com/gluon-lang/gluon},
  urldate = {2024-04-26},
  abstract = {A static, type inferred and embeddable language written in Rust.},
  organization = {gluon-lang},
  keywords = {compiler,embeddable,functional,gluon,language,programming-language,repl,rust,type-inference}
}

@software{ref_rspy,
  title = {{{RustPython}}/{{Parser}}},
  date = {2024-04-25T09:35:56Z},
  origdate = {2023-05-05T15:07:12Z},
  url = {https://github.com/RustPython/Parser},
  urldate = {2024-04-26},
  organization = {RustPython}
}

@software{ref_rustc,
  title = {Rust-Lang/Rust},
  date = {2024-04-26T11:35:38Z},
  origdate = {2010-06-16T20:39:03Z},
  url = {https://github.com/rust-lang/rust},
  urldate = {2024-04-26},
  abstract = {Empowering everyone to build reliable and efficient software.},
  organization = {The Rust Programming Language},
  keywords = {compiler,hacktoberfest,language,rust}
}

@software{ref_swiftc,
  title = {Apple/Swift},
  date = {2024-04-26T11:40:58Z},
  origdate = {2015-10-23T21:15:07Z},
  url = {https://github.com/apple/swift},
  urldate = {2024-04-26},
  abstract = {The Swift Programming Language},
  organization = {Apple}
}

@software{ref_tcc,
  title = {{{TCC}} : {{Tiny C Compiler}}},
  author = {Bellard, Fabrice},
  url = {https://bellard.org/tcc/},
  urldate = {2024-04-26},
  version = {0.9.24},
  file = {/home/ian/Zotero/storage/ZFK57LIW/tcc.html}
}

@online{REGISTERALLOCATION,
  title = {{{REGISTER ALLOCATION}}},
  url = {https://pages.cs.wisc.edu/~horwitz/CS701-NOTES/5.REGISTER-ALLOCATION.html},
  urldate = {2024-03-04}
}

@online{rijkeIntroductionHomotopyType2022,
  title = {Introduction to {{Homotopy Type Theory}}},
  author = {Rijke, Egbert},
  date = {2022-12-21},
  eprint = {2212.11082},
  eprinttype = {arXiv},
  eprintclass = {math},
  doi = {10.48550/arXiv.2212.11082},
  url = {http://arxiv.org/abs/2212.11082},
  urldate = {2024-10-06},
  abstract = {This is an introductory textbook to univalent mathematics and homotopy type theory, a mathematical foundation that takes advantage of the structural nature of mathematical definitions and constructions. It is common in mathematical practice to consider equivalent objects to be the same, for example, to identify isomorphic groups. In set theory it is not possible to make this common practice formal. For example, there are as many distinct trivial groups in set theory as there are distinct singleton sets. Type theory, on the other hand, takes a more structural approach to the foundations of mathematics that accommodates the univalence axiom. This, however, requires us to rethink what it means for two objects to be equal. This textbook introduces the reader to Martin-L\textbackslash "of's dependent type theory, to the central concepts of univalent mathematics, and shows the reader how to do mathematics from a univalent point of view. Over 200 exercises are included to train the reader in type theoretic reasoning. The book is entirely self-contained, and in particular no prior familiarity with type theory or homotopy theory is assumed.},
  pubstate = {prepublished},
  keywords = {03B38,Mathematics - Category Theory,Mathematics - Logic},
  file = {/home/ian/Zotero/storage/6X49MVPW/Rijke - 2022 - Introduction to Homotopy Type Theory.pdf}
}

@online{RISCVScratchCreating2019,
  title = {{{RISC-V}} from Scratch 4: {{Creating}} a Function Prologue for Our {{UART}} Driver (2 / 3)},
  shorttitle = {{{RISC-V}} from Scratch 4},
  date = {2019-07-28T12:42:53+00:00},
  url = {https://twilco.github.io/riscv-from-scratch/2019/07/28/riscv-from-scratch-4.html},
  urldate = {2024-03-03},
  abstract = {A post continuing implementation of an NS16550A UART driver in RISC-V assembly. Function prologues are explained in depth and implemented for uart\_get\_char and uart\_put\_char, diagramming changes to the stack and registers instruction-by-instruction. Topics such as ABIs, calling conventions, stack frames, and more are also discussed.},
  langid = {english},
  organization = {twilco’s blog},
  file = {/home/ian/Zotero/storage/7FEXE73C/riscv-from-scratch-4.html}
}

@software{RiscvsoftwaresrcRiscvisasim2024,
  title = {Riscv-Software-Src/Riscv-Isa-Sim},
  date = {2024-02-26T17:28:53Z},
  origdate = {2011-08-26T20:00:24Z},
  url = {https://github.com/riscv-software-src/riscv-isa-sim},
  urldate = {2024-02-26},
  abstract = {Spike, a RISC-V ISA Simulator},
  organization = {RISC-V Software},
  keywords = {emulation,emulator,emulators,riscv-emulator}
}

@software{RuneProgrammingLanguage,
  title = {The {{Rune Programming Language}}},
  url = {https://github.com/google/rune},
  urldate = {2022-11-27},
  keywords = {open-source,programming-languages}
}

@software{rust,
  title = {Rust Programming Language},
  url = {https://www.rust-lang.org/},
  urldate = {2024-04-24},
  abstract = {A language empowering everyone to build reliable and efficient software.},
  organization = {Mozilla},
  version = {1.77.2},
  file = {/home/ian/Zotero/storage/Y4DWWKCT/www.rust-lang.org.html}
}

@online{RV32IRV64IInstructions,
  title = {{{RV32I}}, {{RV64I Instructions}} — Riscv-Isa-Pages Documentation},
  url = {https://msyksphinz-self.github.io/riscv-isadoc/html/rvi.html#sltu},
  urldate = {2024-04-20},
  file = {/home/ian/Zotero/storage/JBRT4CK6/rvi.html}
}

@online{SDL2IncludeSDL_keyboardh,
  title = {{{SDL2}}/Include/{{SDL}}\_keyboard.h at Master · Zielmicha/{{SDL2}}},
  url = {https://github.com/zielmicha/SDL2/blob/master/include/SDL_keyboard.h},
  urldate = {2024-11-10},
  abstract = {SDL2 with changed (saner?) blending function for SDL\_BLENDMODE\_BLEND - zielmicha/SDL2},
  langid = {english},
  organization = {GitHub},
  file = {/home/ian/Zotero/storage/6L4LEGXZ/SDL_scancode.html}
}

@article{sewellComputerScienceTripos,
  title = {Computer {{Science Tripos}}, {{Part 1B}}},
  author = {Sewell, Peter},
  langid = {english},
  file = {/home/ian/Zotero/storage/9DEGJT93/Sewell - Computer Science Tripos, Part 1B.pdf}
}

@online{SwiftDocsOwnershipManifesto,
  title = {Swift/Docs/{{OwnershipManifesto}}.Md at 01c22b718cfc80a10feaefaf598aa1087f3766c8 · Apple/Swift},
  url = {https://github.com/apple/swift/blob/01c22b718cfc80a10feaefaf598aa1087f3766c8/docs/OwnershipManifesto.md},
  urldate = {2024-01-22},
  abstract = {The Swift Programming Language. Contribute to apple/swift development by creating an account on GitHub.},
  langid = {english},
  organization = {GitHub},
  file = {/home/ian/Zotero/storage/DCH63J84/OwnershipManifesto.html}
}

@online{SwiftsyntaxSourcesSwiftSyntax,
  title = {Swift-Syntax/{{Sources}}/{{SwiftSyntax}}/{{Trivia}}.Swift at Main · Apple/Swift-Syntax},
  url = {https://github.com/apple/swift-syntax/blob/main/Sources/SwiftSyntax/Trivia.swift},
  urldate = {2024-02-12},
  abstract = {A set of Swift libraries for parsing, inspecting, generating, and transforming Swift source code. - apple/swift-syntax},
  langid = {english},
  organization = {GitHub},
  file = {/home/ian/Zotero/storage/JYLW9AP8/SwiftSyntax.html}
}

@online{TimeFliesKoen,
  title = {Time {{Flies}} - {{Koen}} van {{Gilst}}},
  url = {https://time-flies.koenvangilst.nl/},
  urldate = {2024-09-23},
  keywords = {fun,web}
}

@online{toalSyntaxDesign,
  title = {Syntax {{Design}}},
  author = {Toal, Ray},
  url = {https://cs.lmu.edu/~ray/notes/syntaxdesign/},
  urldate = {2023-12-25},
  abstract = {One of the most recognizable features of a languages is its syntax. What are some of the things about syntax that matter? What questions might you ask if you were creating a syntax for your own language?},
  keywords = {topic:programming-languages,topic:syntax},
  file = {/home/ian/Zotero/storage/ZW8LZS6Y/syntaxdesign.html}
}

@article{triskaCorrectnessConsiderationsCLP,
  title = {Correctness {{Considerations}} in {{CLP}}({{FD}}) {{Systems}}},
  author = {Triska, Markus},
  langid = {english},
  file = {/home/ian/Zotero/storage/UZ6G4QN8/Triska - Correctness Considerations in CLP(FD) Systems.pdf}
}

@software{ts,
  title = {Typescript},
  shorttitle = {Typescript},
  url = {https://www.typescriptlang.org/},
  urldate = {2024-04-24},
  abstract = {TypeScript extends JavaScript by adding types to the language. TypeScript speeds up your development experience by catching errors and providing fixes before you even run your code.},
  organization = {Microsoft},
  version = {5.4},
  file = {/home/ian/Zotero/storage/HQSDDNQ2/www.typescriptlang.org.html}
}

@software{tuominenVexuBog2024,
  title = {Vexu/Bog},
  author = {Tuominen, Veikka},
  date = {2024-01-20T03:22:22Z},
  origdate = {2020-01-20T20:04:53Z},
  url = {https://github.com/Vexu/bog},
  urldate = {2024-01-22},
  abstract = {Small, strongly typed, embeddable language.},
  keywords = {compiler,programming-language,zig}
}

@online{UseOpensbiBoot2023,
  title = {Use {{Opensbi}} to Boot Your Own Operating System - {{CV1800B}}({{Duo English Forum}})},
  date = {2023-10-13T06:01:08+00:00},
  url = {http://forum.sophgo.com/t/use-opensbi-to-boot-your-own-operating-system/340},
  urldate = {2024-04-21},
  abstract = {Source: Reprinted from https://community.milkv.io/t/opensbi/681, Original Author Judehahh  Previously, in the article Bootstrapping Your Own Operating System with U-Boot, I attempted to use OpenSBI to bootstrap my own operating system. However, I found that there were formatting requirements for the bl33 image, both when creating the FIP (Firmware Image Package) and during ATF (Arm Trusted Firmware) startup.  During this period, I delved into RISC-V assembly and linker scripts, and then reexamin...},
  langid = {english},
  organization = {Sophgo},
  file = {/home/ian/Zotero/storage/9H69UKTD/340.html}
}

@article{wagnerHistorySensitiveErrorRecovery2000,
  title = {History-{{Sensitive Error Recovery}}},
  author = {Wagner, Tim and Graham, S.L.},
  date = {2000-08-21},
  abstract = {We present a novel approach to incremental recovery from lexical and syntactic errors in an interactive software development environment. Unlike existing techniques, we utilize the history of changes to the program to discover the natural correlation between user modifications and errors detected during incremental lexical and syntactic analysis. Our technique is non-correcting---the analysis refuses to incorporate invalid modifications, while still permitting correct changes to be applied. Errors are presented to the user simply by highlighting the invalid changes. The approach is automated---no user action is required to detect or recover from errors. Multiple textual and structural edits, arbitrary timing of incremental analysis, multiple errors per analysis, and nested errors are supported. Historybased error recovery is language independent and is compatible with the best known methods for incremental lexing and parsing, adding neither time nor space overhead to those algorithms. Effective integration with the environment's history services ensures that other tools can efficiently discover regions of the program (un)affected by errors, and that any transformations of the program required to isolate or present errors are themselves efficiently reversible operations. Keywords--- Error recovery, software development environments, incremental parsing, incremental lexing, development log, program presentation I.},
  keywords = {topic:error-handling,topic:programming-languages},
  file = {/home/ian/Zotero/storage/QS47E5J8/Wagner and Graham - 2000 - History-Sensitive Error Recovery.pdf}
}

@article{zhouProgrammingFinitedomainConstraint2006,
  title = {Programming Finite-Domain Constraint Propagators in {{Action Rules}}},
  author = {Zhou, Neng-Fa},
  date = {2006-09},
  journaltitle = {Theory and Practice of Logic Programming},
  shortjournal = {Theory and Practice of Logic Programming},
  volume = {6},
  number = {5},
  pages = {483--507},
  issn = {1471-0684, 1475-3081},
  doi = {10.1017/S1471068405002590},
  url = {https://www.cambridge.org/core/product/identifier/S1471068405002590/type/journal_article},
  urldate = {2024-07-21},
  abstract = {In this paper, we propose a new language, called AR (Action Rules), and describe how various propagators for finite-domain constraints can be implemented in it. An action rule specifies a pattern for agents, an action that the agents can carry out, and an event pattern for events that can activate the agents. AR combines the goal-oriented execution model of logic programming with the event-driven execution model. This hybrid execution model facilitates programming constraint propagators. A propagator for a constraint is an agent that maintains the consistency of the constraint and is activated by the updates of the domain variables in the constraint. AR has a much stronger descriptive power than indexicals, the language widely used in the current finite-domain constraint systems, and is flexible for implementing not only interval-consistency but also arc-consistency algorithms. As examples, we present a weak arc-consistency propagator for the all distinct constraint and a hybrid algorithm for n-ary linear equality constraints. B-Prolog has been extended to accommodate action rules. Benchmarking shows that B-Prolog as a CLP(FD) system significantly outperforms other CLP(FD) systems.},
  langid = {english},
  file = {/home/ian/Zotero/storage/3A5Q7F6L/Zhou - 2006 - Programming finite-domain constraint propagators in Action Rules.pdf}
}
